#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup (using post-commit hook)..."
echo "Script execution started at: $(date)" # Current date will be used here

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt-get &> /dev/null; then # Changed from apt to apt-get for wider compatibility
      sudo apt-get update && sudo apt-get install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt-get, yum, brew) found. Please install $package manually."
      exit 1
    fi

    if ! command -v "$package" &> /dev/null; then
        echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
        exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl" # curl is needed for API communication
echo "Checkpoint 3: Required packages checked/installed."

CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}      % For colored text
\\usepackage{courier}      % For pcr font family
\\usepackage{xurl}         % For better URL handling

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."

# 4. Define and install the post-commit hook
HOOK_PATH="$GIT_ROOT/.git/hooks/post-commit"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

# Remove old pre-push hook if it exists from previous installations of this tool
OLD_PRE_PUSH_HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
if [ -f "$OLD_PRE_PUSH_HOOK_PATH" ]; then
    if grep -q "CUM pre-push hook" "$OLD_PRE_PUSH_HOOK_PATH" 2>/dev/null; then # Simple check, suppress grep errors
        echo "‚ÑπÔ∏è Removing old CUM pre-push hook at $OLD_PRE_PUSH_HOOK_PATH."
        rm -f "$OLD_PRE_PUSH_HOOK_PATH"
    fi
fi

echo "‚öôÔ∏è  Attempting to install post-commit hook to: $HOOK_PATH"
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

echo "Checkpoint 10: About to write post-commit hook content to $HOOK_PATH."
# This heredoc writes the actual post-commit hook script
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Prevent the hook from running when we are amending the commit from within this hook
if [ "$GIT_CUM_REPORT_AMENDING_COMMIT" = "true" ]; then
  exit 0
fi

# Hook script strict mode
set -e
set -o pipefail

echo "üî• Running CUM post-commit hook (commit details as blue paragraph)..."

GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

# Check if the LaTeX log file exists, if not, recreate it.
if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ö†Ô∏è Hook Warning: LaTeX log file not found at $TEX_FILE_PATH. Recreating it." >&2
    mkdir -p "$(dirname "$TEX_FILE_PATH")"
    # This template must match the one in the main installation script
    cat << EOF_INNER > "$TEX_FILE_PATH"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}      % For colored text
\\usepackage{courier}      % For pcr font family
\\usepackage{xurl}         % For better URL handling

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF_INNER
    if [ $? -ne 0 ]; then
        echo "‚ùå Hook Error: Failed to recreate LaTeX log file at $TEX_FILE_PATH. Summary will not be added." >&2
        exit 0 # Exit gracefully from hook if TeX file can't be made
    fi
    echo "‚úÖ LaTeX log file recreated at $TEX_FILE_PATH."
fi

commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an' HEAD)
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local HEAD)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

changed_files_str=""
is_initial_commit=false
if ! git rev-parse --verify HEAD^ >/dev/null 2>&1; then
    is_initial_commit=true
fi

if $is_initial_commit; then
    echo "üìù Initial commit detected. Listing all files in the commit."
    changed_files_str=$(git diff-tree --no-commit-id --name-only -r HEAD)
else
    echo "üìù Standard commit. Listing changed files against HEAD^."
    changed_files_str=$(git diff --name-only HEAD^ HEAD)
fi

# Using /v1/completions endpoint
VLLM_API_URL="http://10.16.246.2:8001/v1/completions"
MODEL_NAME="TheBloke/CodeLlama-13B-Instruct-AWQ" # This is for the 'model' field in JSON
MAX_TOKENS_PER_FILE=500
MAX_DIFF_CHARS_PER_FILE=4000 # Limit characters in diff sent to LLM

all_files_latex_subsection_blocks=""

OLD_IFS="$IFS"
IFS=$'\n'
changed_files_array=()
while IFS= read -r line; do
    if [[ -n "$line" ]]; then # Only add non-empty lines
        changed_files_array+=("$line")
    fi
done <<< "$changed_files_str"
IFS="$OLD_IFS"


if [ ${#changed_files_array[@]} -eq 0 ] && [ -n "$changed_files_str" ]; then
    echo "‚ö†Ô∏è Warning: Changed files string was not empty but parsed to zero files. Check for unusual filenames or only whitespace."
fi

for file_path in "${changed_files_array[@]}"; do
    if [ -z "$file_path" ]; then # Should be caught by the loop above, but double check
        continue
    fi

    echo "üìÑ Processing file: $file_path"
    file_diff_output_raw=""

    if $is_initial_commit; then
        # For initial commit, show the full file content as the "diff"
        if git show "HEAD:$file_path" &>/dev/null; then # Check if file exists in index
             file_diff_output_raw=$(git show "HEAD:$file_path")
        else
            echo "   ‚ÑπÔ∏è File $file_path listed in initial commit tree but 'git show' failed (possibly removed before first commit or unusual state)."
            file_diff_output_raw="File content not available for initial commit summary."
        fi
    else
        file_diff_output_raw=$(git diff HEAD^ HEAD -- "$file_path")
    fi

    escaped_file_path_for_latex=$(printf '%s\n' "$file_path" | sed 's/\\/\\textbackslash{}/g; s/{/\\{/g; s/}/\\}/g; s/\$/\\\$/g; s/&/\\&/g; s/#/\\#/g; s/_/\\_/g; s/%/\\%/g; s/~/\textasciitilde{}/g; s/\^/\\^{}/g')

    if [ -z "$file_diff_output_raw" ]; then
        echo "   ‚ÑπÔ∏è No textual changes found for $file_path or content unavailable. Skipping API call."
        all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\nNo textual changes detected in this file for this commit.\n\n"
        continue
    fi

    # Sanitize (remove backspace, form feed) and truncate diff
    sanitized_file_diff=$(echo "$file_diff_output_raw" | tr -d '\b\f')
    truncated_file_diff=$(echo "$sanitized_file_diff" | head -c "$MAX_DIFF_CHARS_PER_FILE")
    file_diff_to_send="$truncated_file_diff"
    sanitized_file_diff_len=$(echo -n "$sanitized_file_diff" | wc -c)

    if [ "$sanitized_file_diff_len" -gt "$MAX_DIFF_CHARS_PER_FILE" ]; then
        file_diff_to_send+=$'\n\n[Diff for this file was truncated due to length]'
        echo "   ‚ö†Ô∏è Diff for $file_path was truncated from $sanitized_file_diff_len bytes to $MAX_DIFF_CHARS_PER_FILE characters."
    fi

    # Original prompt content
    user_prompt_content="Summarize the following code changes for the file '$file_path' from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose. Be concise. Diff or content:\n\n$file_diff_to_send"
    # Format for CodeLlama Instruct (Llama-2 style)
    formatted_prompt_for_completion="<s>[INST] $user_prompt_content [/INST]"


    echo "   üìû Contacting LLM API ($MODEL_NAME via /v1/completions) for summary of $file_path..."
    # Payload for /v1/completions endpoint
    payload_file=$(jq -n \
        --arg model_name "$MODEL_NAME" \
        --arg formatted_prompt "$formatted_prompt_for_completion" \
        --argjson max_tokens "$MAX_TOKENS_PER_FILE" \
        '{ model: $model_name, prompt: $formatted_prompt, max_tokens: $max_tokens, stream: false, temperature: 0.7, top_p: 0.95 }') # Added temp & top_p

    file_summary_text_escaped_for_latex=""
    if [ $? -ne 0 ]; then
        echo "   ‚ùå Hook Error: Failed to construct JSON payload for $file_path." >&2
        file_summary_text_escaped_for_latex="Automated summary generation failed: Error constructing API payload for this file."
    else
        api_response_file_stderr=$(mktemp) # To capture curl's stderr
        api_response_file=$(echo "$payload_file" | curl --silent --fail --show-error -X POST \
            -H "Content-Type: application/json" -d @- \
            --connect-timeout 20 --max-time 180 "$VLLM_API_URL" 2> "$api_response_file_stderr")
        curl_exit_status_file=$?
        summary_text_for_file=""

        if [ $curl_exit_status_file -ne 0 ]; then
            echo "   ‚ùå Hook Warning: LLM API request failed for $file_path (curl code: $curl_exit_status_file). Target: $VLLM_API_URL, Model: $MODEL_NAME" >&2
            if [ -s "$api_response_file_stderr" ]; then # Check if stderr file has content
                 echo "   Curl STDERR:" >&2
                 cat "$api_response_file_stderr" >&2
            fi
            # Log the payload that was sent for easier debugging
            echo "   Failed Payload (first 500 chars): $(echo "$payload_file" | head -c 500)..." >&2
            summary_text_for_file="Automated summary generation failed: LLM API request error (curl code: $curl_exit_status_file)."
        else
            # Response parsing for /v1/completions
            if echo "$api_response_file" | jq -e '.choices[0].text' > /dev/null 2>&1; then
                extracted_text_file=$(echo "$api_response_file" | jq -r '.choices[0].text')
                summary_text_for_file="$extracted_text_file"
                echo -e "   ‚úÖ Summary for $file_path received."
            else
                echo "   ‚ùå Hook Warning: Failed to extract summary text for $file_path from /v1/completions response or response was malformed." >&2
                echo "   Raw API Response for $file_path: $api_response_file" >&2 # Log raw response for debugging
                summary_text_for_file="Automated summary generation failed: Could not parse LLM response or response was malformed from /v1/completions."
            fi
        fi
        rm -f "$api_response_file_stderr" # Clean up temp file

        file_summary_text_escaped_for_latex=$(echo "$summary_text_for_file" | sed 's/\f//g' | sed \
            -e 's/\\/\\textbackslash{}/g' -e 's/{/\\{/g'  -e 's/}/\\}/g' \
            -e 's/\$/\\\$/g' -e 's/&/\\&/g' -e 's/#/\\#/g'  -e 's/_/\\_/g' \
            -e 's/%/\\%/g'  -e 's/~/\textasciitilde{}/g' -e 's/\^/\\^{}/g' \
            -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' -e 's/-/--/g')
    fi
    
    all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\n{\\fontfamily{pcr}\\selectfont\n$file_summary_text_escaped_for_latex\n}\n\n"
done

file_summaries_section_content=""
if [ ${#changed_files_array[@]} -eq 0 ]; then
    message=""
    if [ -z "$changed_files_str" ]; then # No files changed at all
        message="No files were part of this commit (e.g., an empty commit). No AI summaries generated."
    else # Files string existed but parsed to empty array (e.g. only whitespace in string)
        message="Could not parse the list of changed files, or only files with non-textual changes were present. No AI summaries generated."
    fi
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
elif [ -z "$all_files_latex_subsection_blocks" ]; then # Should not happen if array has items, unless all items resulted in error or no textual change
    message="No textual changes found in modified files for AI summary, or summary generation failed for all relevant files."
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
else
    file_summaries_section_content="$all_files_latex_subsection_blocks"
fi

escaped_commit_author=$(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g')
escaped_commit_date=$(echo "$commit_date" | sed 's/_/\\_/g')
section_title="Commit $commit_short_hash by $escaped_commit_author ($escaped_commit_date)"

commit_details_paragraph=""
commit_details_paragraph+="{\\color{blue}\\small % Start color blue and make text small\n"
commit_details_paragraph+="Commit: \\texttt{$commit_hash} \\\\\n"
commit_details_paragraph+="Author: $escaped_commit_author \\\\\n"
commit_details_paragraph+="Date: $escaped_commit_date\n"
commit_details_paragraph+="} % End color blue\n"

section_content="\\section{$section_title}
$file_summaries_section_content
$commit_details_paragraph
\\hrulefill
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"

export CUM_REPORT_AWK_SECTION_CONTENT="$section_content"
# Use a temporary file for awk script to handle potential complex characters in section_content
awk_script_file=$(mktemp)
echo '/\\end\{document\}/{printf "%s\n", ENVIRON["CUM_REPORT_AWK_SECTION_CONTENT"]}1' > "$awk_script_file"

awk -f "$awk_script_file" "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?
rm -f "$awk_script_file" # Clean up awk script file
unset CUM_REPORT_AWK_SECTION_CONTENT

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summaries for commit $commit_short_hash appended to $TEX_FILE_PATH"
        echo " amending commit to include TeX log update..."
        git add "$TEX_FILE_PATH"
        export GIT_CUM_REPORT_AMENDING_COMMIT=true
        # Use --no-verify to prevent other hooks (like pre-commit, commit-msg) from running during amend
        git commit --amend --no-edit -C HEAD --no-verify
        unset GIT_CUM_REPORT_AMENDING_COMMIT
        echo "‚úÖ Commit amended to include TeX log update."
    else
        echo "‚ùå Hook Warning: Failed to move temporary TeX file. TeX log not updated." >&2
        rm -f "$TMP_TEX_FILE" # Clean up temp tex file on error
    fi
else
    echo "‚ùå Hook Warning: Failed to write summary to TeX file using awk (status: $awk_status). TeX log not updated." >&2
    rm -f "$TMP_TEX_FILE" # Clean up temp tex file on error
fi

echo "‚úÖ CUM post-commit hook (commit details as blue paragraph) finished for $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF
# End of heredoc for the hook script

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write post-commit hook script content to $HOOK_PATH." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo ""
echo "üéâ CUM Report setup complete with a post-commit hook!"
echo "‚ÑπÔ∏è  The hook is now configured to send requests to your vLLM API using the /v1/completions endpoint at: http://10.16.246.2:8001/v1/completions"
echo "    for model: TheBloke/CodeLlama-13B-Instruct-AWQ"
echo "    Prompts are now formatted with '<s>[INST] ... [/INST]'."
echo "‚ÄºÔ∏è IMPORTANT: Ensure your vLLM server at http://10.16.246.2:8001 is running and"
echo "    is serving the model 'TheBloke/CodeLlama-13B-Instruct-AWQ' (or the name it expects for it)."
echo "    This change (using /v1/completions) bypasses the chat template issue on the server."
echo "    If you later configure your vLLM server with a proper chat template for this model,"
echo "    you might consider reverting the hook to use /v1/chat/completions for a more standard approach."
echo ""
echo "After each 'git commit', the summary will be generated and the commit will be amended to include the changes to '$INITIAL_TEX_FILE'."
echo "Your working directory should remain clean regarding this file after a commit."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo ""
echo "If the hook doesn't run after 'git commit', check 'git config core.hooksPath'."
echo "If 'core.hooksPath' is set to something other than '.git/hooks', you may need to manually place the hook there."
echo "Script execution finished at: $(date)" # Current date will be used here

exit 0

