#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup (using post-commit hook)..."
echo "Script execution started at: $(date)"

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt &> /dev/null; then
      sudo apt update && sudo apt install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt, yum, brew) found. Please install $package manually."
      exit 1
    fi

    if ! command -v "$package" &> /dev/null; then
         echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
         exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl"
echo "Checkpoint 3: Required packages checked/installed."

CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{courier}

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit and included herein.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each section corresponds to a summary generated at the time of a commit.
The summaries are generated by an AI model based on the diff of the commit.

\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."

# 4. Define and install the post-commit hook
HOOK_PATH="$GIT_ROOT/.git/hooks/post-commit" # CHANGED to post-commit
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

# Remove old pre-push hook if it exists from previous installations of this tool
OLD_PRE_PUSH_HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
if [ -f "$OLD_PRE_PUSH_HOOK_PATH" ]; then
    # Check if it's our hook by looking for a unique string, e.g., "CUM pre-push hook"
    # This is a simple check; more robust would be a hash or specific comment
    if grep -q "CUM pre-push hook" "$OLD_PRE_PUSH_HOOK_PATH"; then
        echo "‚ÑπÔ∏è Removing old CUM pre-push hook at $OLD_PRE_PUSH_HOOK_PATH."
        rm -f "$OLD_PRE_PUSH_HOOK_PATH"
    fi
fi

echo "‚öôÔ∏è  Attempting to install post-commit hook to: $HOOK_PATH"
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

echo "Checkpoint 10: About to write post-commit hook content to $HOOK_PATH."
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Prevent the hook from running when we are amending the commit from within this hook
if [ "$GIT_CUM_REPORT_AMENDING_COMMIT" = "true" ]; then
  exit 0
fi

# Hook script strict mode
set -e 
set -o pipefail

echo "üî• Running CUM post-commit hook..."

GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1 # Should not happen in a post-commit hook context
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ùå Hook Error: LaTeX log file not found at $TEX_FILE_PATH." >&2
    echo "Please ensure it exists or re-run the CUM Report installation script." >&2
    # Don't fail the commit for this, but log it.
    exit 0
fi

# For post-commit, HEAD is the commit that was just made
commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an' HEAD)
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local HEAD)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

# Get the diff of the commit just made (HEAD) against its parent (HEAD^)
# For the initial commit which has no parent, this will error. Handle it.
if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
    diff_output=$(git diff HEAD^ HEAD --pretty=format:) # Diff against parent
else
    # This is the initial commit, show its full tree
    diff_output=$(git show --pretty=format: HEAD)
fi


if [ -z "$diff_output" ]; then
  echo "‚ö†Ô∏è No textual changes found in commit $commit_short_hash to summarize (or initial commit structure). Skipping API call."
  # If it's an empty commit or just the initial commit before any real files, don't try to summarize.
  exit 0 
fi

prompt_text="Summarize the following code changes from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose:\n\n$diff_output"

VLLM_API_URL="http://10.16.246.2:8001/v1/chat/completions"
MODEL_NAME="deepseek-ai/deepseek-moe-16b-chat" 
MAX_TOKENS=700

echo "üìû Contacting LLM API at $VLLM_API_URL for summary..."
payload=$(jq -n \
            --arg model_name "$MODEL_NAME" \
            --arg user_prompt "$prompt_text" \
            --argjson max_tokens "$MAX_TOKENS" \
            '{
              model: $model_name,
              messages: [
                {role: "user", content: $user_prompt}
              ],
              max_tokens: $max_tokens,
              stream: false
            }')

if [ $? -ne 0 ]; then
    echo "‚ùå Hook Error: Failed to construct JSON payload with jq." >&2
    exit 0 
fi

api_response=$(curl --silent --fail --show-error -X POST \
  -H "Content-Type: application/json" \
  -d "$payload" \
  --connect-timeout 15 \
  --max-time 120 \
  "$VLLM_API_URL")
curl_exit_status=$?

summary_text=""

if [ $curl_exit_status -ne 0 ]; then
  echo "‚ùå Hook Warning: Failed to connect to LLM API or API returned an error (curl code: $curl_exit_status)." >&2
  echo "   URL: $VLLM_API_URL. Commit will proceed without summary." >&2
  summary_text="Automated summary generation failed: LLM API request error (curl code: $curl_exit_status)."
else
  extracted_text=$(echo "$api_response" | jq -r '.choices[0].message.content') 

  if [ "$extracted_text" != "null" ] && [ -n "$extracted_text" ]; then
    summary_text="$extracted_text"
    echo -e "‚úÖ Commit summary received from LLM."
  else
    echo "‚ùå Hook Warning: Failed to extract summary from LLM response or response was empty." >&2
    echo "   Raw API Response (first 500 chars): $(echo "$api_response" | head -c 500)" >&2
    summary_text="Automated summary generation failed: Could not parse LLM response or response was empty."
  fi
fi

escaped_summary=$(echo "$summary_text" | sed \
  -e 's/\\/\\textbackslash{}/g' \
  -e 's/{/\\{/g'   -e 's/}/\\}/g' \
  -e 's/\$/\\\$/g' -e 's/&/\\&/g' \
  -e 's/#/\\#/g'   -e 's/_/\\_/g' \
  -e 's/%/\\%/g'   -e 's/~/\\textasciitilde{}/g' \
  -e 's/\^/\\^{}/g' \
  -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' \
  -e 's/-/--/g')

section_title="Commit $commit_short_hash by $(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g') ($(echo "$commit_date" | sed 's/_/\\_/g'))"

section_content="\\section*{$section_title}
\\subsubsection*{AI Generated Summary}
{\\fontfamily{pcr}\\selectfont
$escaped_summary
}
\\subsubsection*{Commit Details}
\\begin{itemize}
    \\item \\textbf{Commit Hash:} $commit_hash
    \\item \\textbf{Author:} $(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g')
    \\item \\textbf{Date:} $(echo "$commit_date" | sed 's/_/\\_/g')
\\end{itemize}
\\hrulefill
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"
awk -v section="$section_content" '/\\end\{document\}/{print section}1' "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summary for commit $commit_short_hash appended to $TEX_FILE_PATH"
        echo " amending commit to include this change..."
        git add "$TEX_FILE_PATH"
        # Set a flag to prevent re-entry into this hook
        export GIT_CUM_REPORT_AMENDING_COMMIT=true
        git commit --amend --no-edit -C HEAD # Use -C HEAD to reuse original commit message, author, date
        unset GIT_CUM_REPORT_AMENDING_COMMIT
        echo "‚úÖ Commit amended to include TeX log update."
    else
        echo "‚ùå Hook Warning: Failed to move temporary TeX file. TeX log not updated in commit." >&2
        rm -f "$TMP_TEX_FILE" 
    fi
else
    echo "‚ùå Hook Warning: Failed to write summary to TeX file using awk. TeX log not updated in commit." >&2
    rm -f "$TMP_TEX_FILE" 
fi

echo "‚úÖ CUM post-commit hook finished for $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write post-commit hook script content to $HOOK_PATH." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then 
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo "üéâ CUM Report setup complete with a post-commit hook!"
echo "After each 'git commit', the summary will be generated and the commit will be amended to include the changes to '$INITIAL_TEX_FILE'."
echo "Your working directory should remain clean regarding this file after a commit."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo ""
echo "If the hook doesn't run after 'git commit', check 'git config core.hooksPath'."
echo "Script execution finished at: $(date)"

exit 0