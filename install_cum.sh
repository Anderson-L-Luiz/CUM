#!/bin/bash

set -e # Exit immediately if a command exits with a non-zero status.

echo "üöÄ Starting CUM Report installation and setup..."

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"

# Optional: Enforce running from the root directory itself
# if [ "$(pwd)" != "$GIT_ROOT" ]; then
#   echo "‚ùå Error: This script must be run from the root of the Git repository ($GIT_ROOT)."
#   echo "Please 'cd $GIT_ROOT' and rerun the script."
#   exit 1
# fi

# 2. Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    # Attempt to install using sudo apt. This might need user password.
    # Add other package managers if needed (e.g., yum, brew)
    if command -v apt &> /dev/null; then
      sudo apt update && sudo apt install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: Package manager not found (apt, yum, brew). Please install $package manually."
      exit 1
    fi

    if [ $? -eq 0 ]; then
      echo "‚úÖ $package installed successfully."
    else
      echo "‚ùå Error installing $package. Please install it manually and rerun this script."
      exit 1
    fi
  else
    echo "üëç $package is already installed."
  fi
}

# Install required packages: jq and curl
install_package "jq"
install_package "curl"

# 3. Create CUM_report directory and initial LaTeX file
CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
mkdir -p "$CUM_REPORT_DIR"
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip} % For better paragraph spacing without indentation
\\usepackage{hyperref} % For clickable table of contents

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Pre-Push Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits pushed to the repository, generated automatically.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each section corresponds to a summary generated at the time of a 'git push'.
The summaries are generated by an AI model based on the diff of the latest commit.

\\end{document}
EOF
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi

# 4. Define and install the pre-push hook
HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

echo "‚öôÔ∏è  Installing pre-push hook to: $HOOK_PATH"

# Ensure the .git/hooks directory exists
mkdir -p "$HOOK_DIR_PATH"

# Define the pre-push hook script content
# Note the 'EOF' is quoted to prevent variable expansion in the here-document AT DEFINITION TIME.
# Variables like $commit, $diff will be expanded when the hook RUNS.
read -r -d '' PRE_PUSH_HOOK_CONTENT << 'EOF'
#!/bin/bash

set -e # Exit on error

echo "üî• Running CUM pre-push hook..."

# Determine Git Root (hooks run from the root of the working tree)
GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

# Get the last commit on the current branch (the one about to be pushed)
# For a more sophisticated hook, you might parse stdin to get the range of commits being pushed.
# See: https://git-scm.com/docs/githooks#_pre_push
# For now, summarizing HEAD is a common approach.
commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an')
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

# Get the diff for the latest commit
# Using --pretty=format: ensures only the diff part is captured by 'git show'
diff_output=$(git show --format="--pretty=format:" "$commit_hash")

if [ -z "$diff_output" ]; then
  echo "‚ö†Ô∏è No changes found in commit $commit_short_hash to summarize. Skipping summary."
  # If you still want to add an entry:
  # summary="No textual changes detected in commit $commit_short_hash."
  # title="Commit $commit_short_hash - $(date +'%Y%m%d_%H%M%S') - No Changes"
  # escaped_summary=$(echo "$summary" | sed ...) # escape it
  # section="\\section{$title}\n$escaped_summary\n"
  # sed -i '/\\end{document}/i '"$section" "$TEX_FILE_PATH" # Insert before \end{document}
  # echo "‚úÖ Logged 'No Changes' to $TEX_FILE_PATH"
  exit 0 # Exit successfully, allow push
fi

# Construct the prompt for the LLM
prompt_text="Summarize the following code changes from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose:\n\n$diff_output"

# vLLM API Configuration
VLLM_API_URL="http://10.16.246.2:8001/generate" # Updated API URL
MODEL_NAME="deepseek-ai/deepseek-moe-16b-chat" # Or your specific model
MAX_TOKENS=700 # Adjust as needed

echo "üìû Contacting LLM API at $VLLM_API_URL for summary..."

# Format payload robustly using jq
# The 'prompt' field for the /generate endpoint typically expects a string.
# jq will handle JSON escaping of the prompt_text.
payload=$(jq -n \
            --arg prompt_content "$prompt_text" \
            --arg model_name "$MODEL_NAME" \
            --argjson max_tokens "$MAX_TOKENS" \
            '{prompt: $prompt_content, model: $model_name, max_tokens: $max_tokens, stream: false}')

# Call the API
# Use curl -f to fail silently on server errors (HTTP 4xx or 5xx) and make curl return an error code.
# Add --connect-timeout and --max-time for resilience
api_response=$(curl -s -f -X POST \
  -H "Content-Type: application/json" \
  -d "$payload" \
  --connect-timeout 10 \
  --max-time 60 \
  "$VLLM_API_URL")

if [ $? -ne 0 ]; then
  echo "‚ùå Error: Failed to connect to LLM API or API returned an error."
  echo "Curl exit code: $?"
  echo "If the push is critical, you can bypass this hook with 'git push --no-verify'"
  # To allow the push despite failure, exit 0. To block, exit 1.
  # For now, let's allow the push but log the failure.
  summary="Failed to connect to LLM API. Summary not generated. Curl exit code: $?."
  echo "$summary"
else
  # Extract summary from response - this path is specific to some vLLM /generate endpoints
  # Example: {"text": ["Generated summary text here..."], "results": [...]} -> .text[0]
  # Or: {"results": [{"text": "Generated summary..."}]} -> .results[0].text
  # Adjust jq query based on your actual API response structure.
  extracted_text=$(echo "$api_response" | jq -r '.text[0]') # Common for vLLM /generate if prompt is a single string

  if [ "$extracted_text" == "null" ] || [ -z "$extracted_text" ]; then
      # Try another common path if the first failed
      extracted_text=$(echo "$api_response" | jq -r '.results[0].text')
  fi


  if [ "$extracted_text" != "null" ] && [ -n "$extracted_text" ]; then
    summary="$extracted_text"
    echo -e "‚úÖ Commit summary received:\n$summary"
  else
    summary="‚ùå Failed to extract summary from LLM response. The response structure might have changed or an error occurred."
    echo "$summary"
    echo "Raw API Response: $api_response" # Log the raw response for debugging
  fi
fi

# Escape LaTeX special characters in the summary
escaped_summary=$(echo "$summary" | sed \
  -e 's/\\/\\textbackslash{}/g' \
  -e 's/{/\\{/g'   -e 's/}/\\}/g' \
  -e 's/\$/\\\$/g' -e 's/&/\\&/g' \
  -e 's/#/\\#/g'   -e 's/_/\\_/g' \
  -e 's/%/\\%/g'   -e 's/~/\$\\sim\$/g' \
  -e 's/\^/\\^{}/g' \
  -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' \
  -e 's|\[|{[}\\[{]}|g' \
  -e 's|\]|{[}\\]{]}|g' \
  -e 's/-/--/g') # Escape hyphens for better line breaking

# Prepare LaTeX section title and content
# Using commit hash, author, and date for a more descriptive section title
section_title="Commit $commit_short_hash by $commit_author ($commit_date)"
section_content="\\section*{$section_title} % Using section* for unnumbered sections, add to TOC manually if needed
\\subsection*{Summary}
{\\fontfamily{pcr}\\selectfont % Potentially use a monospaced font for summary
$escaped_summary
}
\\subsection*{Commit Details}
\\begin{itemize}
    \\item \\textbf{Commit Hash:} $commit_hash
    \\item \\textbf{Author:} $commit_author
    \\item \\textbf{Date:} $commit_date
\\end{itemize}
\\hrulefill % A horizontal line before the next entry
"

# Append the new section before \end{document} in the LaTeX file
# Using awk for safer multi-line insertion before a pattern
awk -v section="$section_content" '/\\end\{document\}/{print section}1' "$TEX_FILE_PATH" > tmp_commit_log.tex && mv tmp_commit_log.tex "$TEX_FILE_PATH"

echo "‚úÖ Summary for commit $commit_short_hash appended to $TEX_FILE_PATH"
echo "Pre-push summary generation complete."

# Exit 0 to allow the push, or exit 1 to block it if something went wrong and you want to enforce it.
exit 0
EOF

# Write the hook script content to the hook file
echo "$PRE_PUSH_HOOK_CONTENT" > "$HOOK_PATH"

# Make the hook executable
chmod +x "$HOOK_PATH"

echo "‚úÖ Pre-push hook installed and made executable at $HOOK_PATH."
echo "üéâ CUM Report setup complete!"
echo "On your next 'git push', the latest commit will be summarized and added to '$INITIAL_TEX_FILE'."
echo "Remember to compile '$INITIAL_TEX_FILE' (e.g., with pdflatex) to view the report."