#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup..."
echo "Script execution started at: $(date)"

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt &> /dev/null; then
      sudo apt update && sudo apt install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt, yum, brew) found. Please install $package manually."
      exit 1
    fi

    # Check again if installation was successful
    if ! command -v "$package" &> /dev/null; then
         echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
         exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl"
echo "Checkpoint 3: Required packages checked/installed."

# 3. Create CUM_report directory
CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

# Create initial LaTeX file if it doesn't exist
INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip} % For better paragraph spacing without indentation
\\usepackage{hyperref} % For clickable table of contents
\\usepackage[T1]{fontenc} % Recommended for font encoding
\\usepackage{lmodern} % For better font rendering, includes textasciitilde
\\usepackage{amsmath} % For \$\\sim\$ if used, and other math
\\usepackage{courier} % Example for monospaced font (pcr)

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Pre-Push Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits pushed to the repository, generated automatically.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each section corresponds to a summary generated at the time of a 'git push'.
The summaries are generated by an AI model based on the diff of the latest commit.

\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."


# 4. Define and install the pre-push hook
HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

echo "‚öôÔ∏è  Attempting to install pre-push hook to: $HOOK_PATH"

# Ensure the .git/hooks directory exists
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

# Write the hook script content directly to the hook file using cat <<EOF > file
# The 'HOOK_SCRIPT_EOF' delimiter must be on a line by itself with no leading/trailing whitespace.
echo "Checkpoint 10: About to write pre-push hook content to $HOOK_PATH."
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Hook script strict mode
set -e 
set -o pipefail

echo "üî• Running CUM pre-push hook..."

# Determine Git Root (hooks run from the root of the working tree)
GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1 # Critical error for the hook
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ùå Hook Error: LaTeX log file not found at $TEX_FILE_PATH. Aborting hook." >&2
    exit 1 # Critical error for the hook
fi

# Get the last commit on the current branch
commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an')
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

# CORRECTED LINE: Use --pretty=format: to get only the diff
diff_output=$(git show --pretty=format: "$commit_hash")

if [ -z "$diff_output" ]; then
  echo "‚ö†Ô∏è No textual changes found in commit $commit_short_hash to summarize. Skipping API call."
  exit 0 # Exit successfully, allow push
fi

prompt_text="Summarize the following code changes from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose:\n\n$diff_output"

VLLM_API_URL="http://10.16.246.2:8001/generate"
MODEL_NAME="deepseek-ai/deepseek-moe-16b-chat" 
MAX_TOKENS=700

echo "üìû Contacting LLM API at $VLLM_API_URL for summary..."
payload=$(jq -n \
            --arg prompt_content "$prompt_text" \
            --arg model_name "$MODEL_NAME" \
            --argjson max_tokens "$MAX_TOKENS" \
            '{prompt: $prompt_content, model: $model_name, max_tokens: $max_tokens, stream: false}')

if [ $? -ne 0 ]; then
    echo "‚ùå Hook Error: Failed to construct JSON payload with jq. Check jq installation and payload logic." >&2
    exit 0 # Allowing push, but logging error
fi

api_response=$(curl --silent --fail --show-error -X POST \
  -H "Content-Type: application/json" \
  -d "$payload" \
  --connect-timeout 15 \
  --max-time 120 \
  "$VLLM_API_URL")
curl_exit_status=$?

summary_text="" # Initialize summary_text

if [ $curl_exit_status -ne 0 ]; then
  echo "‚ùå Hook Error: Failed to connect to LLM API or API returned an error." >&2
  echo "Curl exit code: $curl_exit_status. This might be due to network issues, API server down, incorrect URL, or the payload being rejected." >&2
  summary_text="Automated summary generation failed: LLM API request error (curl code: $curl_exit_status)."
else
  extracted_text=$(echo "$api_response" | jq -r '.text[0]') 
  if [ "$extracted_text" == "null" ] || [ -z "$extracted_text" ]; then
      extracted_text=$(echo "$api_response" | jq -r '.results[0].text')
  fi

  if [ "$extracted_text" != "null" ] && [ -n "$extracted_text" ]; then
    summary_text="$extracted_text"
    echo -e "‚úÖ Commit summary received from LLM."
  else
    echo "‚ùå Hook Error: Failed to extract summary from LLM response. The response structure might be unexpected or an API-side error occurred." >&2
    echo "Raw API Response (first 500 chars for brevity): $(echo "$api_response" | head -c 500)" >&2
    summary_text="Automated summary generation failed: Could not parse LLM response or response was empty."
  fi
fi

# CORRECTED TILDE ESCAPING
escaped_summary=$(echo "$summary_text" | sed \
  -e 's/\\/\\textbackslash{}/g' \
  -e 's/{/\\{/g'   -e 's/}/\\}/g' \
  -e 's/\$/\\\$/g' -e 's/&/\\&/g' \
  -e 's/#/\\#/g'   -e 's/_/\\_/g' \
  -e 's/%/\\%/g'   -e 's/~/\\textasciitilde{}/g' \
  -e 's/\^/\\^{}/g' \
  -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' \
  -e 's/-/--/g')

section_title="Commit $commit_short_hash by $(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g') ($(echo "$commit_date" | sed 's/_/\\_/g'))"

section_content="\\section*{$section_title}
\\subsubsection*{AI Generated Summary}
{\\fontfamily{pcr}\\selectfont % courier font family for monospaced
$escaped_summary
}
\\subsubsection*{Commit Details}
\\begin{itemize}
    \\item \\textbf{Commit Hash:} $commit_hash
    \\item \\textbf{Author:} $(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g')
    \\item \\textbf{Date:} $(echo "$commit_date" | sed 's/_/\\_/g')
\\end{itemize}
\\hrulefill % A horizontal line before the next entry
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"
awk -v section="$section_content" '/\\end\{document\}/{print section}1' "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summary for commit $commit_short_hash appended to $TEX_FILE_PATH"
    else
        echo "‚ùå Hook Error: Failed to move temporary TeX file $TMP_TEX_FILE to $TEX_FILE_PATH." >&2
        rm -f "$TMP_TEX_FILE" 
    fi
else
    echo "‚ùå Hook Error: Failed to write summary to $TEX_FILE_PATH using awk (awk exit code: $awk_status). Temporary file: $TMP_TEX_FILE" >&2
    rm -f "$TMP_TEX_FILE" 
fi

echo "‚úÖ Pre-push summary generation process complete for commit $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write hook script content to $HOOK_PATH." >&2
    echo "This might be due to disk full, permissions issues, or problems with the 'cat' command / here-document structure." >&2
    exit 1
fi
echo "‚úÖ Pre-push hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then 
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    echo "This indicates a fundamental problem with the script writing process. Check permissions and disk space." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable. Check permissions." >&2
    exit 1
fi
echo "‚úÖ Pre-push hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo "üéâ CUM Report setup complete!"
echo "On your next 'git push', the latest commit should be summarized and added to '$INITIAL_TEX_FILE'."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo ""
echo "If the hook does not seem to run during 'git push':"
echo "1. Check if Git is configured to use a different hooks path: 'git config core.hooksPath'"
echo "   If this shows a path, Git uses that directory instead of '.git/hooks/'."
echo "   You can unset it for this repo with: 'git config --unset core.hooksPath'"
echo "2. Manually inspect the created hook: 'cat $HOOK_PATH'"
echo "Script execution finished at: $(date)"

exit 0