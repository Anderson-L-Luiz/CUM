#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup (using post-commit hook)..."
echo "Script execution started at: $(date)" # Current date will be used here

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt &> /dev/null; then
      sudo apt update && sudo apt install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt, yum, brew) found. Please install $package manually."
      exit 1
    fi

    if ! command -v "$package" &> /dev/null; then
        echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
        exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl"
echo "Checkpoint 3: Required packages checked/installed."

CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}         % For colored text
\\usepackage{courier}        % For pcr font family
\\usepackage{xurl}           % For better URL handling

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."

# 4. Define and install the post-commit hook
HOOK_PATH="$GIT_ROOT/.git/hooks/post-commit"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

# Remove old pre-push hook if it exists from previous installations of this tool
OLD_PRE_PUSH_HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
if [ -f "$OLD_PRE_PUSH_HOOK_PATH" ]; then
    if grep -q "CUM pre-push hook" "$OLD_PRE_PUSH_HOOK_PATH" 2>/dev/null; then # Simple check, suppress grep errors
        echo "‚ÑπÔ∏è Removing old CUM pre-push hook at $OLD_PRE_PUSH_HOOK_PATH."
        rm -f "$OLD_PRE_PUSH_HOOK_PATH"
    fi
fi

echo "‚öôÔ∏è  Attempting to install post-commit hook to: $HOOK_PATH"
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

echo "Checkpoint 10: About to write post-commit hook content to $HOOK_PATH."
# This heredoc writes the actual post-commit hook script
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Prevent the hook from running when we are amending the commit from within this hook
if [ "$GIT_CUM_REPORT_AMENDING_COMMIT" = "true" ]; then
  exit 0
fi

# Hook script strict mode
set -e
set -o pipefail

echo "üî• Running CUM post-commit hook (commit details as blue paragraph)..."

GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

# Check if the LaTeX log file exists, if not, recreate it.
if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ö†Ô∏è Hook Warning: LaTeX log file not found at $TEX_FILE_PATH. Recreating it." >&2
    mkdir -p "$(dirname "$TEX_FILE_PATH")"
    # This template must match the one in the main installation script
    cat << EOF_INNER > "$TEX_FILE_PATH"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}         % For colored text
\\usepackage{courier}        % For pcr font family
\\usepackage{xurl}           % For better URL handling

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF_INNER
    if [ $? -ne 0 ]; then
        echo "‚ùå Hook Error: Failed to recreate LaTeX log file at $TEX_FILE_PATH. Summary will not be added." >&2
        exit 0
    fi
    echo "‚úÖ LaTeX log file recreated at $TEX_FILE_PATH."
fi

commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an' HEAD)
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local HEAD)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

changed_files_str=""
is_initial_commit=false
if ! git rev-parse --verify HEAD^ >/dev/null 2>&1; then
    is_initial_commit=true
fi

if $is_initial_commit; then
    echo "üìù Initial commit detected. Listing all files in the commit."
    changed_files_str=$(git diff-tree --no-commit-id --name-only -r HEAD)
else
    echo "üìù Standard commit. Listing changed files against HEAD^."
    changed_files_str=$(git diff --name-only HEAD^ HEAD)
fi

VLLM_API_URL="http://10.16.246.2:8001/v1/chat/completions" # Ensure this is your correct vLLM API URL
MODEL_NAME="deepseek-ai/deepseek-moe-16b-chat"
MAX_TOKENS_PER_FILE=500
MAX_DIFF_CHARS_PER_FILE=4000

all_files_latex_subsection_blocks=""

OLD_IFS="$IFS"
IFS=$'\n'
changed_files_array=($changed_files_str) # Convert newline-separated string to array
IFS="$OLD_IFS"

if [ ${#changed_files_array[@]} -eq 0 ] && [ -n "$changed_files_str" ]; then
    echo "‚ö†Ô∏è Warning: Changed files string was not empty but parsed to zero files. Check for unusual filenames."
fi

for file_path in "${changed_files_array[@]}"; do
    if [ -z "$file_path" ]; then
        continue
    fi

    echo "üìÑ Processing file: $file_path"
    file_diff_output_raw=""

    if $is_initial_commit; then
        file_diff_output_raw=$(git diff 4b825dc642cb6eb9a060e54bf8d69288fbee4904 HEAD -- "$file_path")
    else
        file_diff_output_raw=$(git diff HEAD^ HEAD -- "$file_path")
    fi

    escaped_file_path_for_latex=$(printf '%s\n' "$file_path" | sed 's/\\/\\textbackslash{}/g; s/{/\\{/g; s/}/\\}/g; s/\$/\\\$/g; s/&/\\&/g; s/#/\\#/g; s/_/\\_/g; s/%/\\%/g; s/~/\textasciitilde{}/g; s/\^/\\^{}/g')

    if [ -z "$file_diff_output_raw" ]; then
        echo "  ‚ÑπÔ∏è No textual changes found for $file_path. Skipping API call."
        all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\nNo textual changes detected in this file for this commit.\n\n"
        continue
    fi

    sanitized_file_diff=$(echo "$file_diff_output_raw" | tr -d '\b\f')
    truncated_file_diff=$(echo "$sanitized_file_diff" | head -c "$MAX_DIFF_CHARS_PER_FILE")
    file_diff_to_send="$truncated_file_diff"
    sanitized_file_diff_len=$(echo -n "$sanitized_file_diff" | wc -c)

    if [ "$sanitized_file_diff_len" -gt "$MAX_DIFF_CHARS_PER_FILE" ]; then
        file_diff_to_send+=$'\n\n[Diff for this file was truncated due to length]'
        echo "  ‚ö†Ô∏è Diff for $file_path was truncated from $sanitized_file_diff_len bytes to $MAX_DIFF_CHARS_PER_FILE characters."
    fi

    prompt_text_file="Summarize the following code changes for the file '$file_path' from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose. Be concise:\n\n$file_diff_to_send"

    echo "  üìû Contacting LLM API for summary of $file_path..."
    payload_file=$(jq -n \
        --arg model_name "$MODEL_NAME" \
        --arg user_prompt "$prompt_text_file" \
        --argjson max_tokens "$MAX_TOKENS_PER_FILE" \
        '{ model: $model_name, messages: [{role: "user", content: $user_prompt}], max_tokens: $max_tokens, stream: false }')

    file_summary_text_escaped_for_latex=""
    if [ $? -ne 0 ]; then
        echo "  ‚ùå Hook Error: Failed to construct JSON payload for $file_path." >&2
        file_summary_text_escaped_for_latex="Automated summary generation failed: Error constructing API payload for this file."
    else
        api_response_file=$(echo "$payload_file" | curl --silent --fail --show-error -X POST \
            -H "Content-Type: application/json" -d @- \
            --connect-timeout 20 --max-time 180 "$VLLM_API_URL")
        curl_exit_status_file=$?
        summary_text_for_file=""

        if [ $curl_exit_status_file -ne 0 ]; then
            echo "  ‚ùå Hook Warning: LLM API request failed for $file_path (curl code: $curl_exit_status_file)." >&2
            summary_text_for_file="Automated summary generation failed: LLM API request error (curl code: $curl_exit_status_file)."
        else
            extracted_text_file=$(echo "$api_response_file" | jq -r '.choices[0].message.content // ""')
            if [ -n "$extracted_text_file" ] && [ "$extracted_text_file" != "null" ]; then
                summary_text_for_file="$extracted_text_file"
                echo -e "  ‚úÖ Summary for $file_path received."
            else
                echo "  ‚ùå Hook Warning: Failed to extract summary for $file_path or response was empty/null." >&2
                summary_text_for_file="Automated summary generation failed: Could not parse LLM response or response was empty/null."
            fi
        fi
        file_summary_text_escaped_for_latex=$(echo "$summary_text_for_file" | sed 's/\f//g' | sed \
            -e 's/\\/\\textbackslash{}/g' -e 's/{/\\{/g'  -e 's/}/\\}/g' \
            -e 's/\$/\\\$/g' -e 's/&/\\&/g' -e 's/#/\\#/g'  -e 's/_/\\_/g' \
            -e 's/%/\\%/g'  -e 's/~/\textasciitilde{}/g' -e 's/\^/\\^{}/g' \
            -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' -e 's/-/--/g')
    fi
    
    all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\n{\\fontfamily{pcr}\\selectfont\n$file_summary_text_escaped_for_latex\n}\n\n"
done

file_summaries_section_content=""
if [ ${#changed_files_array[@]} -eq 0 ]; then
    message=""
    if [ -z "$changed_files_str" ]; then
        message="No files were part of this commit. No AI summaries generated."
    else
        message="Could not parse the list of changed files. No AI summaries generated."
    fi
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
elif [ -z "$all_files_latex_subsection_blocks" ]; then
    message="No textual changes found in modified files for AI summary, or summary generation failed for all relevant files."
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
else
    file_summaries_section_content="$all_files_latex_subsection_blocks"
fi

escaped_commit_author=$(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g')
escaped_commit_date=$(echo "$commit_date" | sed 's/_/\\_/g')
section_title="Commit $commit_short_hash by $escaped_commit_author ($escaped_commit_date)"

commit_details_paragraph=""
commit_details_paragraph+="{\\color{blue}\\small % Start color blue and make text small\n"
commit_details_paragraph+="Commit: \\texttt{$commit_hash} \\\\\n"
commit_details_paragraph+="Author: $escaped_commit_author \\\\\n"
commit_details_paragraph+="Date: $escaped_commit_date\n"
commit_details_paragraph+="} % End color blue\n"

section_content="\\section{$section_title}
$file_summaries_section_content
$commit_details_paragraph
\\hrulefill
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"

export CUM_REPORT_AWK_SECTION_CONTENT="$section_content"
awk '/\\end\{document\}/{printf "%s\n", ENVIRON["CUM_REPORT_AWK_SECTION_CONTENT"]}1' "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?
unset CUM_REPORT_AWK_SECTION_CONTENT

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summaries for commit $commit_short_hash appended to $TEX_FILE_PATH"
        echo " amending commit to include TeX log update..."
        git add "$TEX_FILE_PATH"
        export GIT_CUM_REPORT_AMENDING_COMMIT=true
        git commit --amend --no-edit -C HEAD
        unset GIT_CUM_REPORT_AMENDING_COMMIT
        echo "‚úÖ Commit amended to include TeX log update."
    else
        echo "‚ùå Hook Warning: Failed to move temporary TeX file. TeX log not updated." >&2
        rm -f "$TMP_TEX_FILE"
    fi
else
    echo "‚ùå Hook Warning: Failed to write summary to TeX file using awk (status: $awk_status). TeX log not updated." >&2
    rm -f "$TMP_TEX_FILE"
fi

echo "‚úÖ CUM post-commit hook (commit details as blue paragraph) finished for $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF
# End of heredoc for the hook script

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write post-commit hook script content to $HOOK_PATH." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo ""
echo "üéâ CUM Report setup complete with a post-commit hook!"
echo "After each 'git commit', the summary will be generated and the commit will be amended to include the changes to '$INITIAL_TEX_FILE'."
echo "Your working directory should remain clean regarding this file after a commit."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo ""
echo "If the hook doesn't run after 'git commit', check 'git config core.hooksPath'."
echo "If 'core.hooksPath' is set to something other than '.git/hooks', you may need to manually place the hook there."
echo "Script execution finished at: $(date)" # Current date will be used here

exit 0